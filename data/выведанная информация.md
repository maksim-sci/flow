# Выведанная информация

## межузельные положения в Hf02

Да! они там есть. Позволяют перемещаться дефектам.

## Вакансии
имеют заряд +2
>Defect_generation_and_activation_process (Rolf Öttking)
## Межузельный кислород
имеют заряд -2
>Defect_generation_and_activation_process (Rolf Öttking)

## Алгоритм
Выбирается размеры ячейки: Lx Ly Lz

=> В обратном пр-ве переходят в размеры 2\*PI/Lx 2\*PI/Ly 2\*PI/Lz (g1, g2, g3)

Выбираем количество ячеек обратного пространства ds: gcut acut

Выбираем ограничения расстояния для поиска: 

```
Обходим все атомы i:

    Обходим все атомы j:
        вычисляем расстояния между атомами:
        xx = ai.x-aj.x
        yy = ai.y-aj.y
        yz = ai.z-aj.z
        Теперь работаем с обратным пространством:
        тогда, для всех x,y,z в (-ds,ds):
            положение в обратном пространстве:
            gx = g1*x
            gy = g2*y
            gz = g3*z
                если расстояние в обратном пространстве < gcut:
                    расстояние в обратном пространстве больше нуля:
                        считаем g_2 = gx\*gy+gx\*gz+gz\*gy
                        >тогда, вклад в энергию:
                        u = qi\*qj/g_2\*exp(-g_2/(4\*kappa\*kappa))\*cos(g_x\*xx+g_y\*yy+g_z\*zz)
                Теперь считаем в реальном пространстве:
                    a1 = x\*Lx+xx
                    a2 = y\*Ly+yy
                    a3 = z\*Lz+zz
                    len = Vector(a1,a2,a3).abs()

                    aa1 = x\*Lx
                    aa2 = y\*Ly
                    aa3 = z\*Lz

                    delta = Vector(aa1,aa2,aa3).abs()
                    Если delta < acat:
                        Если обхождение обратного пространства оканчивается в нуле (позиция самого атома):
                            u = qi*qj*erfc(kappa*len)/len

```